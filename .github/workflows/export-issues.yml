name: Export Issues to Own Repo

on:
  workflow_dispatch:
    inputs:
      labels:
        description: "Comma-separated labels (optional). If empty, file will be named report_ALL.json"
        required: false
        default: ""
      source_path:
        description: "Source repo (owner/name) to read issues from"
        required: true
        default: ""
      source_repo:
        description: "Source repo (owner/name) to read issues from"
        required: true
        default: "https-multiculturaltoolbox-com/edge7"
      dest_repo:
        description: "Destination repo (owner/name)"
        required: true
        default: "pacuitinfo/edge43"
      dest_branch:
        description: "Destination branch"
        required: false
        default: "main"
      dest_path:
        description: "Path in destination repo for monthly-status.json (e.g., data/monthly-status.json or data/)"
        required: false
        default: "data/monthly-status.json"

      # Inputs for BigJsonReader (kept; adjust if needed)
      dateStart:
        description: "Source owner (where big JSON lives)"
        required: false
        default: ""
      dateEnd:
        description: "Source repo"
        required: false
        default: ""
      region:
        description: "Path to big JSON in source repo"
        required: false
        default: "VII"
      path:
        description: "Path to big JSON in source repo"
        required: true
        default: "cache/report_ALL.json"
      

jobs:
  export:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    steps:
      - name: Checkout current repo (for scripts / BigJsonReader code)
        uses: actions/checkout@v4

      - name: Ensure jq and gh
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y jq
          fi
          if ! command -v gh >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y gh
          fi

      - name: Fetch issues via GraphQL (no 1k cap, debug-friendly)
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
          REPO: ${{ github.event.inputs.source_repo || github.repository }}
          STATE: ${{ 'open' }}                         # open|closed|all
          LABELS_IN: ${{ github.event.inputs.labels || '' }}  # comma-separated (optional)
          REGION: ${{ github.event.inputs.region || '' }}     # optional single label, e.g. VII
          DATE_START: ${{ github.event.inputs.dateStart || '' }} # ISO8601
          DATE_END: ${{ github.event.inputs.dateEnd   || '' }}   # ISO8601
        run: |
          set -euo pipefail
          mkdir -p cache

          echo "REPO=${REPO} | STATE=${STATE} | LABELS_IN=${LABELS_IN} | REGION=${REGION} | DATE_START=${DATE_START} | DATE_END=${DATE_END}"
          [ -n "${GH_TOKEN:-}" ] || { echo "‚ùå GH_TOKEN missing"; exit 1; }

          OWNER="${REPO%%/*}"
          NAME="${REPO##*/}"

          # Probe repo access first (prints real error if any)
          read -r -d '' Q_PROBE <<'EOF'
          query($owner:String!, $name:String!) {
            repository(owner:$owner, name:$name){ id isPrivate nameWithOwner viewerPermission }
          }
          EOF
          VARS_PROBE=$(jq -n --arg owner "$OWNER" --arg name "$NAME" '{owner:$owner,name:$name}')
          PROBE=$(curl -sS -X POST https://api.github.com/graphql \
            -H "Authorization: bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -d "$(jq -n --arg query "$Q_PROBE" --argjson variables "$VARS_PROBE" '{query:$query, variables:$variables}')")
          if jq -e '.errors' >/dev/null <<<"$PROBE"; then
            echo "‚ùå Repo probe failed:"; jq -C '.errors' <<<"$PROBE"
            echo "‚û°Ô∏è  Use a PAT with repo scope (GH_PAT). Ensure workflow has permissions: contents:read, issues:read."
            exit 1
          fi
          echo "‚úÖ Repo OK: $(jq -r '.data.repository.nameWithOwner') (perm: $(jq -r '.data.repository.viewerPermission'))"

          # States enum
          case "${STATE,,}" in
            all)    STATES_JSON='["OPEN","CLOSED"]' ;;
            open)   STATES_JSON='["OPEN"]' ;;
            closed) STATES_JSON='["CLOSED"]' ;;
            *)      STATES_JSON='["OPEN"]' ;;
          esac

          # GraphQL query (no labels/date args; we‚Äôll filter client-side)
          read -r -d '' Q <<'EOF'
          query($owner:String!, $name:String!, $after:String, $states:[IssueState!]) {
            repository(owner:$owner, name:$name) {
              issues(first: 100, after: $after, states: $states, orderBy:{field:CREATED_AT, direction:ASC}) {
                nodes {
                  number title body state url createdAt updatedAt closedAt
                  labels(first: 100) { nodes { name } }
                }
                pageInfo { endCursor hasNextPage }
              }
            }
          }
          EOF

          OUT_TMP="$(mktemp)"; echo "[]" > "$OUT_TMP"
          AFTER=null; BATCH=0

          while :; do
            BATCH=$((BATCH+1)); echo "üîé Batch $BATCH (after: ${AFTER})"
            VARS=$(jq -n --arg owner "$OWNER" --arg name "$NAME" --argjson after "$AFTER" --argjson states "$STATES_JSON" \
              '{owner:$owner, name:$name, after:$after, states:$states}')

            RESP=$(curl -sS -X POST https://api.github.com/graphql \
              -H "Authorization: bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -d "$(jq -n --arg query "$Q" --argjson variables "$VARS" '{query:$query, variables:$variables}')")

            if jq -e '.errors' >/dev/null <<<"$RESP"; then
              echo "‚ùå GraphQL errors:"; jq -C '.errors' <<<"$RESP"
              echo "‚ÑπÔ∏è pageInfo:"; jq '.data.repository.issues.pageInfo // {}' <<<"$RESP" || true
              exit 1
            fi

            NODES=$(jq '.data.repository.issues.nodes' <<<"$RESP")
            COUNT=$(jq 'length' <<<"$NODES")
            [ "$COUNT" -eq 0 ] && break

            # Client-side filters
            # 1) Labels: keep if matches REGION and/or any of LABELS_IN
            REGION_LABEL=$(printf '%s' "${REGION:-}")
            LABELS_CSV=$(printf '%s' "${LABELS_IN:-}")
            NODES=$(jq --arg region "$REGION_LABEL" --arg labels_csv "$LABELS_CSV" '
              . as $arr
              | if ($region=="" and $labels_csv=="") then $arr
                else
                  $wanted := ( ($labels_csv|split(",")|map(gsub("^\\s+|\\s+$";""))|map(select(length>0))) + (if $region=="" then [] else [$region] end) ) | unique;
                  [ $arr[] | select( any(.labels.nodes[]?; .name as $n | $wanted | index($n)) ) ]
                end
            ' <<<"$NODES")

            # 2) Date range: createdAt within [DATE_START, DATE_END] if provided
            if [ -n "${DATE_START:-}" ]; then
              NODES=$(jq --arg s "$DATE_START" '[ .[] | select(.createdAt >= $s) ]' <<<"$NODES")
            fi
            if [ -n "${DATE_END:-}" ]; then
              NODES=$(jq --arg e "$DATE_END"   '[ .[] | select(.createdAt <= $e) ]' <<<"$NODES")
            fi

            jq --argjson add "$NODES" '. + $add' "$OUT_TMP" > "${OUT_TMP}.next" && mv "${OUT_TMP}.next" "$OUT_TMP"

            HAS_NEXT=$(jq -r '.data.repository.issues.pageInfo.hasNextPage' <<<"$RESP")
            END_CURSOR=$(jq -r '.data.repository.issues.pageInfo.endCursor' <<<"$RESP")
            [ "$HAS_NEXT" = "true" ] || break
            AFTER=$(jq -Rn --arg c "$END_CURSOR" '$c')
          done

          FINAL=$(jq '
            [ .[]
              | {
                  Number: .number,
                  Title:  .title,
                  Body:   (.body // ""),
                  State:  .state,
                  Url:    .url,
                  Labels: (.labels.nodes | map(.name))
                }
            ]
          ' "$OUT_TMP")

          OUT_PATH="cache/report:${DATE_START:+${DATE_START}:}${DATE_END:+${DATE_END}:}${REGION}"
          printf '%s' "$FINAL" > "$OUT_PATH"
          echo "Preview:"; jq '.[0:3]' "$OUT_PATH" || true
          [ -s "$OUT_PATH" ] || { echo "‚ùå No issues produced (check labels/date filters)."; exit 1; }

      - name: Show preview
        shell: bash
        env:
          LABELS_IN: ${{ github.event.inputs.labels || '' }}
          DATE_START: ${{ github.event.inputs.dateStart }}
          DATE_END: ${{ github.event.inputs.dateEnd }}
          REGION: ${{ github.event.inputs.region }}
        run: |
          SAFE=$(printf '%s' "${LABELS_IN}" | tr ' ,/' '_' | tr -cd 'A-Za-z0-9._-')
          SAFE=${SAFE:-ALL}
          issuesJson="cache/report:${DATE_START:+${DATE_START}:}${DATE_END:+${DATE_END}:}${REGION}"
          echo "SAFE=${SAFE}"
          jq '.[0:3]' "${issuesJson}" || true

      - name: Checkout destination repo (for early copy, if you want the raw issues file there too)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.inputs.dest_repo }}
          ref: ${{  'main' }}
          path: dest
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Copy file into destination path (raw issues JSON)
        shell: bash
        env:
          LABELS_IN: ${{ github.event.inputs.labels || '' }}
          DATE_START: ${{ github.event.inputs.dateStart }}
          DATE_END: ${{ github.event.inputs.dateEnd }}
          REGION: ${{ github.event.inputs.region }}
        run: |
          set -euo pipefail
          SAFE=$(printf '%s' "${LABELS_IN}" | tr ' ,/' '_' | tr -cd 'A-Za-z0-9._-')
          SAFE=${SAFE:-ALL}
          issuesJson="cache/report:${DATE_START:+${DATE_START}:}${DATE_END:+${DATE_END}:}${REGION}"
          destFile="dest/report:${DATE_START:+${DATE_START}:}${DATE_END:+${DATE_END}:}${REGION}"
          echo "Copying ${issuesJson} ‚Üí ${destFile}"
          [ -f "${issuesJson}" ] || { echo "‚ùå Missing ${issuesJson}"; exit 1; }
          mkdir -p "$(dirname "$destFile")"
          cp "${issuesJson}" "${destFile}"

      - name: Commit & push (raw issues JSON)
        working-directory: dest
        env:
          DEST_BRANCH: ${{ github.event.inputs.dest_branch || 'main' }}
        run: |
          set -euo pipefail
          git config user.name  "github-actions"
          git config user.email "actions@users.noreply.github.com"

          git fetch origin "$DEST_BRANCH" || true
          git checkout -B "$DEST_BRANCH" "origin/$DEST_BRANCH"

          git add -A
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi
          git commit -m "chore: export issues (raw) [skip ci]"

          lease_sha="$(git rev-parse "origin/$DEST_BRANCH" || echo)"
          # correct --force-with-lease syntax
          git push --force-with-lease=refs/heads/$DEST_BRANCH:$lease_sha origin HEAD:$DEST_BRANCH

      - name: Run BigJsonReader
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
          REPONAMEREFRESH: ${{secrets.REPONAMEREFRESH}}
          REPOOWNER: ${{secrets.REPOOWNER}}
          GH_REFRESH_PAT: ${{secrets.GH_REFRESH_PAT}}
          REPONAME: ${{secrets.REPONAME}}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DATE_START: ${{ github.event.inputs.dateStart }}
          DATE_END: ${{ github.event.inputs.dateEnd }}
          REGION: ${{ github.event.inputs.region }}
        run: |
          set -euo pipefail
          # If BigJsonReader expects to read from a GitHub repo (NOT local file),
          # it will use the workflow_dispatch inputs below.
          DATE_PARTS=""
          [ -n "${DATE_START:-}" ] && DATE_PARTS="${DATE_START}"
          [ -n "${DATE_END:-}" ] && DATE_PARTS="${DATE_PARTS:+${DATE_PARTS}:}${DATE_END}"

          dotnet run --project src/Tools/BigJsonReader/BigJsonReader.csproj -- \
            --owner "${{ github.repository_owner }}" \
            --repo  "${{ github.repository  }}" \
            --path  "${{ github.repository_owner  }}" \
            --regionKey "report:${DATE_START:+${DATE_START}:}${DATE_END:+${DATE_END}:}${REGION}" \
            --ref   "${{ 'main'   }}" \
            --out "artifacts/monthly-status.json"

      - name: Checkout destination repo (final write)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.inputs.dest_repo }}
          ref: ${{  'main' }}
          path: dest
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Copy files into destination path (status + issues)
        shell: bash
        env:
          DEST_PATH: ${{ github.event.inputs.dest_path || 'data/monthly-status.json' }}
          LABELS_IN: ${{ github.event.inputs.labels || '' }}
          DATE_START: ${{ github.event.inputs.dateStart }}
          DATE_END: ${{ github.event.inputs.dateEnd }}
          REGION: ${{ github.event.inputs.region }}
        run: |
          set -euo pipefail
          SAFE=$(printf '%s' "${LABELS_IN}" | tr ' ,/' '_' | tr -cd 'A-Za-z0-9._-')
          SAFE=${SAFE:-ALL}
          issuesJson="cache/report:${DATE_START:+${DATE_START}:}${DATE_END:+${DATE_END}:}${REGION}"

          # 1) Place monthly-status.json exactly at DEST_PATH
          DEST1="dest/${DEST_PATH}"
          mkdir -p "$(dirname "$DEST1")"
          

          # 2) Place issues JSON alongside DEST_PATH
          if [[ "$DEST_PATH" == */ ]]; then
            issues_dest_dir="$DEST_PATH"
          else
            issues_dest_dir="$(dirname "$DEST_PATH")"
          fi
          DEST2="dest/${issues_dest_dir}/report:${DATE_START}:${DATE_END}:${REGION}"
          mkdir -p "$(dirname "$DEST2")"
          [ -f "$issuesJson" ] || { echo "‚ùå issues JSON missing: $issuesJson"; exit 1; }
          cp "$issuesJson" "$DEST2"

          echo "Wrote:"
          echo "  $DEST1"
          echo "  $DEST2"

      - name: Commit & push (final)
        working-directory: dest
        env:
          DEST_BRANCH: ${{ github.event.inputs.dest_branch || 'main' }}
        run: |
          set -euo pipefail
          git config user.name  "github-actions"
          git config user.email "actions@users.noreply.github.com"

          git fetch origin "$DEST_BRANCH" || true
          git checkout -B "$DEST_BRANCH" "origin/$DEST_BRANCH"

          git add -A
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi
          git commit -m "chore: export issues & monthly status [skip ci]"

          lease_sha="$(git rev-parse "origin/$DEST_BRANCH" || echo)"
          git push --force-with-lease=refs/heads/$DEST_BRANCH:$lease_sha origin HEAD:$DEST_BRANCH
